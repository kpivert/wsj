<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.525">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>hilltop</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="hilltop_files/libs/clipboard/clipboard.min.js"></script>
<script src="hilltop_files/libs/quarto-html/quarto.js"></script>
<script src="hilltop_files/libs/quarto-html/popper.min.js"></script>
<script src="hilltop_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="hilltop_files/libs/quarto-html/anchor.min.js"></script>
<link href="hilltop_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="hilltop_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="hilltop_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="hilltop_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="hilltop_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<p>May 6, 2025</p>
<p>What’s the Impact of Eliminating Medicaid Provider Taxes?</p>
<p>Medicaid is a joint state-federal program, and states are required to fund a portion of total spending. States are currently permitted to tax health care providers up to 6% to help fund the state share. A potential Medicaid reform would lower this threshold—potentially to 0%—and thus reduce federal Medicaid funding for many states. The Congressional Budget Oﬃce estimates that reducing the threshold to 0% would lead to $612 billion in federal savings over 10 years.</p>
<p>How would this impact federal Medicaid spending in individual states?</p>
<p>How do provider taxes work?</p>
<p>Almost every state has at least one type of provider tax. States use provider tax revenue to partially ﬁnance their share of total Medicaid spending.</p>
<p>Provider tax revenue and federal matching revenue, based on the Federal Medical Assistance Percentage (FMAP), is then returned to the state’s health system and used for a variety of purposes.</p>
<p>Currently, states are permitted to eﬀectively collect up to 6% of net patient revenue per provider class. This is referred to as the “safe harbor” limit.</p>
<p>States with high FMAP &amp; high provider tax rates would be most aﬀected if the safe harbor limit is removed.</p>
<p>The impact of removing the 6% provider tax threshold depends on each state’s provider tax rates and FMAP:  Higher provider tax rates translate to a higher</p>
<p>state share of Medicaid spending.</p>
<p> Higher FMAP translates to a higher federal</p>
<p>match on the state share and thus more total Medicaid funding.</p>
<p>Data and methods Provider tax rates are imputed from Kaiser Family Foundation. We use the lower bound of each tax rate range for states with a provider tax in place and assume a 1.0% rate if it is presented as ≤3.5%. Although 19 classes of providers can be subject to provider taxes, we focus on nursing facilities (NFs) and hospitals. Therefore, these estimates likely understate true eﬀects.</p>
<p>Total net patient revenue data by state for general, short-term hospitals are from FY 2023 Medicare Cost Reports and FY 2021 Medicare Cost Reports for nursing facilities. We calculate blended FY 2023 FMAPs and use FY 2023 total Medicaid expenditure from the Medicaid Budget and Expenditure System, and use traditional FMAPs from Kaiser Family Foundation. Where necessary, we use a 3% growth rate assumption to trend quantities to FY 2026.</p>
<p>If provider taxes are eliminated, at least $83.7 billion in annual federal Medicaid funding is at risk in FY 2026.</p>
<p>Lost Federal Medicaid Spending ($ Millions)*</p>
<p>Due to Hospital Taxes</p>
<p>$1,868.2 $2,714.0 $1,296.9 $2,047.7 $502.8 $2,700.8 $1,399.6 $1,036.2 $1,269.9 $3,356.2 $4,856.9 $4,885.8 $1,978.1 $4,758.8 $319.7 $2,527.9 $2,955.4 $1,326.7 $1,741.4 $2,837.2 $3,673.8 $6,739.9 $379.9 $1,398.5 $271.0</p>
<p>Due to NF Taxes</p>
<p>$241.7 $0.0 $38.9 $236.8 $25.3 $269.1 $197.4 $25.4 $62.6 $317.9 $359.0 $31.0 $167.8 $607.4 $18.6 $89.4 $32.8 $138.5 $73.0 $0.0 $361.6 $67.9 $49.8 $97.0 $58.2</p>
<p>Hospital + NF</p>
<p>$2,109.9 $2,714.0 $1,335.8 $2,284.5 $528.1 $2,969.9 $1,597.0 $1,061.6 $1,332.5 $3,674.1 $5,215.9 $4,916.8 $2,145.9 $5,366.2 $338.3 $2,617.3 $2,988.2 $1,465.2 $1,814.4 $2,837.2 $4,035.4 $6,807.8 $429.7 $1,495.5 $329.2</p>
<p>State</p>
<p>% of Total Federal Share 37.90% WV 37.86% NC 35.90% NY 35.57% WY 32.05% OH 30.33% ME 30.19% KY 29.63% HI 28.53% GA 27.56% AR 27.43% WI 25.88% NJ 25.58% DC 23.12% PA 23.04% LA 21.61% MD 21.41% MA 20.72% CA 20.13% WA 18.39% DE 17.99% NM 17.46% NE 17.00% SD 11.87% AK 10.71% ND</p>
<p>Due to Hospital Taxes</p>
<p>$299.4 $968.1 $5,631.9 $29.8 $1,296.5 $165.6 $704.8 $112.7 $701.4 $296.7 $426.8 $546.4 $131.1 $889.1 $609.9 $270.8 $417.3 $2,385.5 $491.8 $0.0 $0.0 $0.0 $0.0 $0.0 $0.0</p>
<p>Due to NF Taxes</p>
<p>Hospital + NF</p>
<p>% of Total Federal Share</p>
<p>$166.9 $473.5 $498.1 $9.0 $752.5 $76.1 $235.1 $43.7 $57.7 $179.4 $30.1 $278.7 $44.0 $571.5 $47.6 $169.3 $163.4 $716.1 $81.8 $44.3 $86.0 $13.5 $0.0 $0.0 $0.0</p>
<p>$466.3 $1,441.6 $6,130.0 $38.8 $2,049.0 $241.7 $939.9 $156.4 $759.1 $476.1 $456.9 $825.1 $175.1 $1,460.6 $657.5 $440.1 $580.7 $3,101.6 $573.6 $44.3 $86.0 $13.5 $0.0 $0.0 $0.0</p>
<p>9.53% 9.49% 9.32% 8.15% 8.11% 7.44% 6.59% 6.52% 6.30% 6.20% 5.48% 5.27% 5.01% 4.98% 4.71% 3.82% 3.81% 3.50% 2.63% 1.71% 1.17% 0.48% 0.00% 0.00% 0.00%</p>
<p>$186.2</p>
<p>$22.7</p>
<p>$208.9</p>
<p>10.06%</p>
<p>Total $75,405.1</p>
<p>$8,328.1</p>
<p>$83,733.2</p>
<p>12.92%</p>
<p>State</p>
<p>MS SC UT AL NH TN IA KS NV MO MI AZ OK FL VT OR IN CT CO VA IL TX RI MN ID</p>
<p>MT</p>
<p>What does this mean? Based on tax revenue collected from hospitals and nursing facilities, states will collect at least $83.7 billion in federal funding for their Medicaid programs in FY 2026. If the safe harbor threshold is eliminated, states will be required to ﬁnd alternative sources of state Medicaid funding, or else lose this federal funding. This will not impact states equally. The elimination of the 6% safe harbor threshold means that several states (Mississippi, South Carolina, Utah, Alabama, New Hampshire, Tennessee, and Iowa) could lose over 30% of their total Medicaid federal funding.</p>
<p>Notes: Florida did not report tax rates, but we imputed nursing facility and hospital tax rates based on correspondence. While this analysis accounts for tax revenue from hospital and nursing facilities, there are other potential sources of tax revenue that we do not include in this analysis. Additionally, the CBO assumes that states will replace half of the lost provider tax revenues with other sources of state funding, but this analysis does not include this assumption. Authors: Morgan Henderson (mhenderson@hilltop.umbc.edu), Leigh Goetschius, and Alice Middleton. With sincere thanks to Dunc Williams of the Medical University of South Carolina for providing the state-level nursing facility net patient revenue data.</p>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>